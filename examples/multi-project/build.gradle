allprojects {
  group = 'rm.examples'
  buildDir = '.build'
  version = '0.0.1'

  repositories {
    mavenLocal()
    mavenCentral()
  }
}

buildscript {
  repositories {
    mavenLocal()
    mavenCentral() //I'll publish here later
    maven { url 'http://repo.spring.io/plugins-release' } //for propdeps
  }
  dependencies {
    classpath(group: 'rm.tools', name: 'nw-gradle', version: '1.+')
    classpath('org.springframework.build.gradle:propdeps-plugin:0.0.+')
  }
}

/**
propdeps?
Because we don't want sap jar files packaged into our archive files, we want to use a 'provided' dependency configuration.
Although gradle does not provide this, except for providedCompile on war projects.
So we can either make a similar configuration outselves, or have propdeps do it for us.

The nw-* plugins support filtering dependencies from provided, providedCompile and providedRuntime.

The nw-ejb plugin also adds a providedRuntime dependency configuration to its own project, but not to
nested project dependencies.
**/

subprojects {
  apply plugin: 'propdeps'
  apply plugin: 'eclipse'
  apply plugin: 'propdeps-eclipse' //this one actually applies propdeps and eclipse

  //nw-web and nw-ejb will apply the java plugin
  //but we need it here if we want to add dependencies up here
  //alternatively, add the common dependencies below
  apply plugin: 'java'
  compileJava {
    options.compilerArgs << '-nowarn'
    sourceCompatibility = JavaVersion.VERSION_1_6
    targetCompatibility = JavaVersion.VERSION_1_6
    //options.compilerArgs << '-XDignore.symbol.file'
  }
  jar {
    archiveName = project.name + '.jar' //no version to match NWDS. good idea or bad?
    rootSpec.eachFile {
      println(" +> $it.name")
    }
  }
  dependencies {
    //we can list common cross-project dependencies here
    //but avoid using provided or providedCompile until after
    //the nw-* plgins are added, so we use the right one
    testCompile('junit:junit:4.+')
    compile('org.apache.commons:commons-lang3:3.4')
  }
}

project(':multi-project-web') {
  apply plugin: 'nw-web'
  apply plugin: 'eclipse-wtp'
  dependencies {
    compile(project(':multi-project-util'))
  }
  //we'll leave sourceSets as defaults (maven convention)
  //feel free to change for your project by uncommenting the following
  //sourceSets.main.java.srcDir 'src' //to match eclipse/NWDS defaults
}

project(':multi-project-ejb') {
  apply plugin: 'nw-ejb'
  dependencies {
    compile(project(':multi-project-util'))
    // providedCompile 'javax.ejb:ejb-api:3.0'
  }
  sourceSets.main.java.srcDir 'ejbModule' //to match NWDS
  sourceSets.test.java.srcDir 'test'
}

project(':multi-project-util') {
  //if java plugin is not applied to all subprojects above,
  //make sure to do so here. all dependent project of nw-web and nw-ejb projects
  //must have the java plugin applied due to some internal gradle requirements

  //apply plugin: 'java'

  //we'll leave sourceSets as defaults (maven convention)
  //feel free to change for your project by uncommenting the following
  //sourceSets.main.java.srcDir 'src' //to match eclipse/NWDS defaults
}

subprojects {

  //This demonstrates adding dependencies after the plugins were added.

  dependencies {

    //Example of provided sap libs. See 'propdeps' for more info on the 'provided' configuration
    if (project.configurations.findByName('providedCompile')) {
      //use providedCompile if possible. Because the standard war task/plugin
      //does not know about 'provided' so it won't get excluded.
      //providedCompile('com.sap.nw:sap.com-tc-logging-java-impl:7.+')
      providedCompile('com.sap.odata:com.sap.core.odata.api:0.7.0') //simulate nw lib
    }
    else {
      //i.e. util/java project
      //'provided' is non-transitive, so it won't get added to a war which
      //depends on the util/java project

      //provided('com.sap.nw:sap.com-tc-logging-java-impl:7.+')
      provided('com.sap.odata:com.sap.core.odata.api:0.7.0') //simulate nw lib
    }
  }

  //The following demonstrates a way to add some hooks for checking when a project has a plugin.
  //Useful for when you have many web or ejb projects in one build script
  //There are other ways to achieve the same, but this is just an example.

  //Note: 'all' executes the given action against all objects in the
  //plugins collection and any objects subsequently added to the collection.
  plugins.all { plugin ->
    //println("plugin: " + plugin.class.simpleName + " added to " + project.name)
    if (plugin instanceof WarPlugin) {
      project.apply plugin: 'eclipse-wtp'
      project.dependencies {
        providedCompile('javax.servlet:servlet-api:2.5', 'javax.servlet:jstl:1.1.2')
      }
      project.eclipse {
        wtp {
          facet {
            facet name: 'jst.web', version: '2.5'
            facet name: 'java', version: '1.6'
          }
          component {
            resource sourcePath: '/WebContent', deployPath: '/'
          }
        }
      }
      project.war {
        archiveName = project.name + '.war' //no version to match NWDS. good idea or bad?
        webXml = project.file('WebContent/WEB-INF/web.xml')
        destinationDir = rootProject.file('dist')
        rootSpec.eachFile {
          println(" +> $it.name")
        }
      }
    }
    else if (plugin.class.name.contains('EjbPlugin')) {
      project.apply plugin: 'eclipse-wtp'
      project.dependencies {
        providedCompile 'javax.ejb:ejb-api:3.0'
      }
      project.eclipse {
        wtp {
          facet {
            facet name: 'jst.ejb', version: '3.0'
            facet name: 'java', version: '1.6'
          }
        }
      }
    }
    else if (plugin.class.name.contains('NwEarPlugin')) {
      nwear {
        //everything here is optional, just as examples
        def vendor = 'rm'
        archiveName = project.name + '.'  + extension
        destinationDir = rootProject.file('dist')
        manifest {
          attributes("Implementation-Vendor-Id": vendor)
        }
        sapManifest {
          attributes("keyvendor": vendor)
        }
        exclude 'application.xml'
        rootSpec.eachFile {
          println(" +> $it.name")
        }
      }
    }
  }

}
